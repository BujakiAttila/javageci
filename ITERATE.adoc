= Iterate Generator

== Introduction

The `iterate` generator can be used when the code contains some kind of
repeated part that is cumbersome to maintain manually. The generator
will scan the file looking for templates that contain code and will
generate core iterating over the values defined in the template.

The following example is a very simple repeated code fragment:

[source,java]
----
    /* TEMPLATE
    {{type}} get_{{type}}Value(){
      {{type}} z = 0;
      return z;
    }

    LOOP type=int|long|short
     */
    //<editor-fold id="getters">
    int get_intValue(){
      int z = 0;
      return z;
    }

    long get_longValue(){
      long z = 0;
      return z;
    }

    short get_shortValue(){
      short z = 0;
      return z;
    }
    //</editor-fold>
----

The template is inside the comment and the part between the
``editor-fold``s is generated.



This structure defines five different selectors. There are five
different editor folds in the code. Each selector can define a
`template()`, a `define()` and a `resolver()`. In the example above only
the first two is used, resolvers are rarely needed.

Templates can be defined by the name of the Java resource or can be
defined as the content of the template itself. In the example above the
template string is defined. It is recognized by the template loader
because the template starts and ends with three back-tick characters.

In the example the last selector is the one that contains the template
for the `configTemplates` editor fold. This template is used for each
value in the code.

== Configuration

=== start

Can define a regular expression pattern. The generator will look for
values only after a line that matches this pattern. (The whole line
should match, not only part of it. In other words `match()` is used and
not only `find()` on the regular expression pattern.) The lines after
the one that matches this pattern until before the line matching the
`end` regular expression pattern will be searched for values.

There can be many start/end pairs in the code at different places. If
there is no line matching the `end` pattern the search for values will
last till the last line of the source file.

=== end

Can define a regular expression pattern. The generator will not look for
values after a line that matches this pattern. The `start` and `end`
regular expression patterns essentially switch on and off the search for
values as the lines of the source code is scanned by the generator.

=== matchLine

Can define a regular expression pattern. If this pattern can be found in
any line between the `start` and `end` pattern then the line will be
used to extract the value. After the matching (using `find()` on the
matcher) the first group will be used as value.

=== values

Values can also be defined as configuration parameter in addition to
being collected from the source code. This configuration parameter can
contains the strings of values comma separated. These values will be
used together to those that were collected from the source code. Usually
programs either collect the values from the source or use this
configuration.

=== valuesSupplier

Values can also be defined in the builder call chain via a
`Function&lt;Class,List&lt;String&gt;&gt;` that may return the list of values that
it calculates from the class object. This function will probably use
reflection to get fields, methods and whatnot from the class.

=== selector

This configuration parameter can only be used in the builder of the
generator to specify the key to the template and defines that follow.
The templates as well as define and resolver lambdas are stored in maps
indexed by the selector and they are used to generate code into editor
fold segments that have the specific selector as id.

=== template

This configuration can only be used in the builder following a selector
to specify the name of a Java resource text file that contains the
template text or the template text itself when the text starts and ends
with three back-tick characters (like code sections in markdown)

=== define

This configuration can only be used in the builder following a selector
to specify a `BiConsumer&lt;Context, String&gt;` that can add segment
parameters for the processing of the template. The consumer gets the
context as a first argument and it can call `ctx.segment()` to get
access to the segment and through that it can add parameters to the
segment. These parameters are (`xxx`,`yyy`) pairs that are used when the
code generation is performed. Every occurence of `{{xxx}}` is replaced
with `yyy`. The second argument to the consumer is the actual value that
the template is used for. The argument passed to the `define()` method
in the builder is usually a lambda expression. This lambda is invoked
for every value in the `values` list.

=== resolver

This configuration can only be used in the builder following a selector
to specify a `BiFunction&lt;Context, String, String&gt;` that can convert the
string as a last step after the parameters were resolved just before the
text is inserted into the generated segment.

=== ctx

This configuration can only be used in the builder to pass an object
that implements the `javax0.geci.templated.Context` interface. In case
there is no such object configured then a default implementation will be
used.

A context passed as a first argument to the lambda expressions when
invoked that are used to define segment parameters referenced in the
template using the `{{xxx}}` format, as well as to resolvers that can
convert the text of the inserted code.

=== mnemonic

This configuration can only be used in the builder to specify the
mnemonic of the generator. The default value is `repeated`. This can be
redefined in case one class needs multiple value lists into different
segments.